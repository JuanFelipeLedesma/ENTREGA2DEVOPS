version: 0.2

env:
  variables:
    COVERAGE_MIN: "98"                 # cobertura mínima para fallar CI
    AWS_DEFAULT_REGION: "us-west-2"    # (Oregón) ajústalo si usas otra región
    ECR_REPO: "blacklist-ms"           # nombre del repo ECR a usar/crear
    CONTAINER_NAME: "blacklist-ms"     # nombre del contenedor en la Task de ECS
    CONTAINER_PORT: "5000"             # puerto expuesto por tu app en el contenedor

phases:
  install:
    runtime-versions:
      python: 3.11
    commands:
      - echo "[INSTALL] Actualizando pip/setuptools/wheel"
      - pip install --upgrade pip setuptools wheel
      - echo "[INSTALL] Dependencias de la app"
      - pip install -r blacklist-ms/requirements.txt
      - echo "[INSTALL] Dependencias de test"
      - |
        if [ -f "requirements-dev.txt" ]; then
          pip install -r requirements-dev.txt
        else
          pip install pytest pytest-cov requests
        fi

  pre_build:
    commands:
      - echo "[PRE_BUILD] Exportando PYTHONPATH y preparando BD SQLite"
      - export PYTHONPATH=$PYTHONPATH:$(pwd)/blacklist-ms
      - export DATABASE_URL=sqlite:///ci.sqlite3
      - |
        python - << 'PY'
        import os
        from application import application as app
        from src.models import db
        from sqlalchemy import inspect

        app.config["SQLALCHEMY_DATABASE_URI"] = os.getenv("DATABASE_URL", "sqlite:///ci.sqlite3")
        with app.app_context():
            db.create_all()
            print("DB bootstrap OK con", app.config["SQLALCHEMY_DATABASE_URI"])
            print("Tablas creadas (bootstrap):", inspect(db.engine).get_table_names())
        PY

  build:
    commands:
      - set -e
      - echo "[BUILD] Ejecutando pruebas con cobertura mínima ${COVERAGE_MIN}%"
      - export DATABASE_URL=sqlite:///ci.sqlite3
      - export PYTHONPATH=$PYTHONPATH:$(pwd)/blacklist-ms
      - |
        python - << 'PY'
        import os
        from application import application as app
        from sqlalchemy import inspect
        from src.models import db

        app.config["SQLALCHEMY_DATABASE_URI"] = os.getenv("DATABASE_URL", "sqlite:///ci.sqlite3")
        with app.app_context():
            print("DB previa a pytest:", app.config["SQLALCHEMY_DATABASE_URI"])
            print("Tablas existentes (pre-pytest):", inspect(db.engine).get_table_names())
        PY

      # Detectar rutas reales para coverage/tests (ahora como scripts multilínea)
      - |
        COV_DIR="src"
        if [ -d "blacklist-ms/src" ]; then
          COV_DIR="blacklist-ms/src"
        fi
        echo "COV_DIR=$COV_DIR"
      - |
        COV_APP="application.py"
        if [ -f "blacklist-ms/application.py" ]; then
          COV_APP="blacklist-ms/application.py"
        fi
        echo "COV_APP=$COV_APP"
      - |
        TEST_DIR="tests"
        if [ -d "blacklist-ms/tests" ]; then
          TEST_DIR="blacklist-ms/tests"
        fi
        echo "TEST_DIR=$TEST_DIR"

      - echo "Usando cobertura en: $COV_DIR y $COV_APP; tests en: $TEST_DIR"
      - echo "DATABASE_URL=${DATABASE_URL}"

      - |
        pytest "$TEST_DIR" -vv --maxfail=1 --disable-warnings \
          --cov="$COV_DIR" \
          --cov="$COV_APP" \
          --cov-report=term-missing \
          --cov-fail-under="${COVERAGE_MIN}"

      # ---------- Build & Push de la imagen a ECR (CD) ----------
      - echo "[BUILD] Preparando ECR e imagen Docker"
      - ACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)
      - ECR_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${ECR_REPO}"
      - IMAGE_TAG=${CODEBUILD_RESOLVED_SOURCE_VERSION:0:7}  # sha corto del commit
      - aws ecr describe-repositories --repository-names "${ECR_REPO}" >/dev/null 2>&1 || \
        aws ecr create-repository --repository-name "${ECR_REPO}"
      - aws ecr get-login-password --region "${AWS_DEFAULT_REGION}" | docker login --username AWS --password-stdin "${ECR_URI}"
      - docker build -t "${ECR_REPO}:latest" -f blacklist-ms/Dockerfile blacklist-ms
      - docker tag "${ECR_REPO}:latest" "${ECR_URI}:${IMAGE_TAG}"
      - docker push "${ECR_URI}:${IMAGE_TAG}"
      - docker tag "${ECR_URI}:${IMAGE_TAG}" "${ECR_URI}:latest"
      - docker push "${ECR_URI}:latest"

  post_build:
    commands:
      - echo "[POST_BUILD] Generando imagedefinitions.json para ECS"
      - rm -rf artifact && mkdir -p artifact
      - printf '[\n  {"name":"%s","imageUri":"%s:%s"}\n]\n' "$CONTAINER_NAME" "$ECR_URI" "$IMAGE_TAG" > artifact/imagedefinitions.json
      - echo "[POST_BUILD] Artefactos generados:" && ls -la artifact

artifacts:
  files:
    - artifact/*
  discard-paths: yes
