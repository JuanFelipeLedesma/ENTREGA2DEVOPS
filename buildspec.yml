version: 0.2

env:
  variables:
    COVERAGE_MIN: "98"                 # cobertura mínima para fallar CI
    AWS_DEFAULT_REGION: "us-west-2"    # región (Oregón)
    ECR_REPO: "blacklist-ms"           # nombre del repo ECR
    CONTAINER_NAME: "blacklist-ms"     # nombre del contenedor en ECS
    CONTAINER_PORT: "5000"             # puerto expuesto por la app en el contenedor

phases:
  install:
    runtime-versions:
      python: 3.11
    commands:
      - echo "[INSTALL] Actualizando pip/setuptools/wheel"
      - pip install --upgrade pip setuptools wheel
      - echo "[INSTALL] Dependencias de la app"
      - pip install -r blacklist-ms/requirements.txt
      - echo "[INSTALL] Dependencias de test"
      - |
          if [ -f "requirements-dev.txt" ]; then
            pip install -r requirements-dev.txt
          else
            pip install pytest pytest-cov requests
          fi

  pre_build:
    commands:
      - echo "[PRE_BUILD] Exportando PYTHONPATH y preparando BD SQLite"
      - export PYTHONPATH=$PYTHONPATH:$(pwd)/blacklist-ms
      - export DATABASE_URL=sqlite:///ci.sqlite3
      - |
          python - << 'PY'
          import os
          from application import application as app
          from src.models import db
          from sqlalchemy import inspect

          app.config["SQLALCHEMY_DATABASE_URI"] = os.getenv("DATABASE_URL", "sqlite:///ci.sqlite3")
          with app.app_context():
              db.create_all()
              print("DB bootstrap OK con", app.config["SQLALCHEMY_DATABASE_URI"])
              print("Tablas creadas:", inspect(db.engine).get_table_names())
          PY

  build:
    commands:
      - echo "[BUILD] Ejecutando pruebas con cobertura mínima ${COVERAGE_MIN}%"
      - export PYTHONPATH=$PYTHONPATH:$(pwd)/blacklist-ms
      - export DATABASE_URL=sqlite:///ci.sqlite3
      - |
          pytest blacklist-ms/tests -vv --maxfail=1 --disable-warnings \
            --cov=blacklist-ms/src \
            --cov=blacklist-ms/application.py \
            --cov-report=term-missing \
            --cov-fail-under="${COVERAGE_MIN}"
      - echo "[BUILD] Construyendo imagen Docker y enviando a ECR"
      - ACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)
      - ECR_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${ECR_REPO}"
      - IMAGE_TAG=${CODEBUILD_RESOLVED_SOURCE_VERSION:0:7}
      - |
          aws ecr describe-repositories --repository-names "${ECR_REPO}" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-name "${ECR_REPO}"
      - aws ecr get-login-password --region "${AWS_DEFAULT_REGION}" \
          | docker login --username AWS --password-stdin "${ECR_URI}"
      - docker build -t "${ECR_REPO}:latest" -f blacklist-ms/Dockerfile blacklist-ms
      - docker tag "${ECR_REPO}:latest" "${ECR_URI}:${IMAGE_TAG}"
      - docker push "${ECR_URI}:${IMAGE_TAG}"
      - docker tag "${ECR_URI}:${IMAGE_TAG}" "${ECR_URI}:latest"
      - docker push "${ECR_URI}:latest"

  post_build:
    commands:
      - echo "[POST_BUILD] Generando imagedefinitions.json para CodePipeline (ECS)"
      - rm -rf artifact && mkdir -p artifact
      - |
          cat > artifact/imagedefinitions.json << EOF
          [
            {
              "name": "${CONTAINER_NAME}",
              "imageUri": "${ECR_URI}:${IMAGE_TAG}"
            }
          ]
          EOF
      - echo "[POST_BUILD] Artefactos generados:"
      - ls -la artifact

artifacts:
  files:
    - artifact/*
  discard-paths: yes
